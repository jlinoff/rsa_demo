'''
Decrypt input file using the RSA algorithm and private key file.

This algorithm expects the format generated by the associated
encryption program (encrypt.py).

It handles two formats: the base64 "JOES RSA" format and the
binary format. It automatically detects the formats.

The first 15 bytes of both are a header that fully describe
the ciphertext data. That header looks like this:

   id              : [0-7] 8 bytes - "joes-rsa"
   version         : [8-9] 2 bytes (0), big-endian
   padding         : [10-11] 2 bytes, size of padding big-endian
   ciphertext      : [12:] bytes of encrypted data
'''
import argparse
import base64
import math
import os
import struct
import sys

try:
    # The right way for 3.8 and beyond.
    from collections.abc import namedtuple
except ImportError:
    from collections import namedtuple

from pyasn1.type import univ
from pyasn1.codec.der import decoder as der_decoder

sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))
from rsa_demo import __version__
from rsa_demo.utils import err, infov, infovv



def getopts() -> argparse.Namespace:
    '''
    Get the command line options.
    '''
    def gettext(string):
        '''
        Convert to upper case to make things consistent.
        '''
        lookup = {
            'usage: ': 'USAGE:',
            'positional arguments': 'POSITIONAL ARGUMENTS',
            'optional arguments': 'OPTIONAL ARGUMENTS',
            'show this help message and exit': 'Show this help message and exit.\n ',
        }
        return lookup.get(string, string)

    argparse._ = gettext  # to capitalize help headers
    base = os.path.basename(sys.argv[0])
    #name = os.path.splitext(base)[0]
    usage = '\n  {0} [OPTIONS]'.format(base)
    desc = 'DESCRIPTION:{0}'.format('\n  '.join(__doc__.split('\n')))
    epilog = f'''\
EXAMPLES:
    # Example 1: help
    $ {base} --help

    # Example 2: RSA encrypt a file
    $ {base} -k test01.pub -i plaintext -o ciphertext

    # Example 3: RSA encrypt a file keep the binary format.
    $ {base} -k test01.pub -i plaintext -o ciphertext -b
'''

    afc = argparse.RawTextHelpFormatter
    parser = argparse.ArgumentParser(formatter_class=afc,
                                     description=desc[:-2],
                                     usage=usage,
                                     epilog=epilog + ' \n')

    parser.add_argument('-i', '--input',
                        action='store',
                        type=str,
                        metavar=('FILE'),
                        help='''\
The file to encrypt.

''')

    parser.add_argument('-k', '--key',
                        action='store',
                        required=True,
                        type=str,
                        metavar=('FILE'),
                        help='''\
The private key file in PKCS#1 private key format.

''')

    parser.add_argument('-o', '--output',
                        action='store',
                        type=str,
                        metavar=('FILE'),
                        help='''\
The decrypted file.
The default is stdout.

''')

    parser.add_argument('-s', '--seed',
                        action='store',
                        type=int,
                        help='''\
Specify a random seed. This helps with demo's but
is not at all secure.

''')

    parser.add_argument('-v', '--verbose',
                        action='count',
                        default=0,
                        help='''\
Output a lot of information about the intermediate steps.

''')

    parser.add_argument('-V', '--version',
                        action='version',
                        version='%(prog)s version {0}'.format(__version__),
                        help='''\
Show program's version number and exit.
''')

    opts = parser.parse_args()
    return opts


# pylint: disable=too-many-locals
def read_pkcs1_prikey(opts: argparse.Namespace) -> namedtuple:
    '''
    Read the RSA private key file.
    '''
    infov(opts, f'reading key file {opts.key}')
    with open(opts.key, 'r') as ifp:
        first, *b64, last = ifp.readlines()
    assert first.strip() == '-----BEGIN RSA PRIVATE KEY-----'
    assert last.strip() == '-----END RSA PRIVATE KEY-----'
    b64_str = ''.join([o.strip() for o in b64])
    b64_bytes = base64.b64decode(b64_str)

    # This is decoded raw, with no structure, that is why
    # recursion is disabled.
    _, msg = der_decoder.decode(b64_bytes, asn1Spec=univ.Sequence(), recursiveFlag=False)
    version, msg = der_decoder.decode(msg, asn1Spec=univ.Integer())
    modulus, msg = der_decoder.decode(msg, asn1Spec=univ.Integer())
    pubexp, msg = der_decoder.decode(msg, asn1Spec=univ.Integer())
    priexp, msg = der_decoder.decode(msg, asn1Spec=univ.Integer())
    prime1, msg = der_decoder.decode(msg, asn1Spec=univ.Integer())
    prime2, msg = der_decoder.decode(msg, asn1Spec=univ.Integer())
    exponent1, msg = der_decoder.decode(msg, asn1Spec=univ.Integer())
    exponent2, msg = der_decoder.decode(msg, asn1Spec=univ.Integer())
    crt_coeff, _ = der_decoder.decode(msg, asn1Spec=univ.Integer())
    rec = {
        'version': version,
        'modulus': int(modulus),
        'pubexp': int(pubexp),
        'priexp': int(priexp),
        'prime1': int(prime1),
        'prime2': int(prime2),
        'exponent1': int(exponent1),
        'exponent2': int(exponent2),
        'crt_coeff': int(crt_coeff),
        }
    ntdef = namedtuple('_', sorted(rec.keys()))
    return ntdef(**rec)
# pylint: enable=too-many-locals


def dump_namedtuple(nto: namedtuple):
    '''
    Generic method for dumping a named tuple.
    '''
    items = []
    maxlen = 0
    for item in sorted(dir(nto)):
        if not item.startswith('_') and item not in ['count', 'index']:
            items.append(item)
            maxlen = max(len(item), maxlen)

    for item in items:
        val = getattr(nto, item)
        try:
            val = int(val)
            if val:
                nbytes = math.ceil(math.log(val, 256))
            else:
                nbytes = 1
        except ValueError:
            nbytes = len(val)
        print(f'   {item:<{maxlen}} : {nbytes:>4}  0x{val:x}')


def read_raw_input(opts: argparse.Namespace):
    '''
    Read the raw ciphertext data.
    It can be either binary or PEM.
    '''
    if opts.input:
        with open(opts.input, 'rb') as ifp:
            return ifp.read()
    infov(opts, 'reading from stdin, type ^D on a new line to exit')
    return bytes(sys.stdin.read(), 'utf-8')


def read_input(opts: argparse.Namespace):
    '''
    Grab the bytes.
    '''
    data = read_raw_input(opts)
    if b'-----BEGIN JOES RSA ENCRYPTED DATA-----' in data:
        # This is the PEM format, grab the binary data.
        first, *b64, last = str(data, 'utf-8').strip().split('\n')
        if first != '-----BEGIN JOES RSA ENCRYPTED DATA-----':
            err('invalid encrypted format: prefix not found')
        if last != '-----END JOES RSA ENCRYPTED DATA-----':
            err('invalid encrypted format: suffix not found')
        b64_str = ''.join([o.strip() for o in b64])
        data = base64.b64decode(b64_str)

    # Check the binary fields.
    if data[:8] != b'joes-rsa':
        err(f'invalid encrypted format: expected prefix not found: {data[:8]}')
    version = struct.unpack('>H', data[8:10])[0]
    if version != 0:
        err(f'invalid encrypted format version: {version}, expected 0')
    padding = struct.unpack('>H', data[10:12])[0]

    infov(opts, f'version: {version}')
    infov(opts, f'size: {len(data[12:])}')

    return data[12:], len(data[12:]), padding


def decrypt(opts: argparse.Namespace, rsa: namedtuple):
    '''
    Decrypt the file data.
    '''
    infov(opts, 'reading the input data')
    ciphertext, size, padding = read_input(opts)
    plaintext = bytes([])
    bytes_per_block = 1 + (math.ceil(math.log(rsa.modulus, 2)) // 8)
    infov(opts, f'bytes/block: {bytes_per_block}')
    infov(opts, f'padding: {padding}')
    for i in range(0, size, bytes_per_block):
        end = i + bytes_per_block
        block = ciphertext[i:end]
        block = bytes([0]) + block

        # Convert the block to an integer for computation.
        block_int = int.from_bytes(block, 'big')

        # Decrypt.
        block_dec_int = int(pow(block_int, rsa.priexp, rsa.modulus))

        # Added to the decrypted bytes array.
        block_bytes = block_dec_int.to_bytes(bytes_per_block, byteorder='big')
        plaintext += block_bytes[1:]  # ignore the extra byte added by encrypt

    if padding:
        plaintext = plaintext[:-padding]

    if opts.output:
        with open(opts.output, 'wb') as ofp:
            ofp.write(plaintext)
    else:
        sys.stdout.write(str(plaintext, 'utf-8'))


def main():
    '''
    main
    '''
    opts = getopts()
    if opts.seed:
        random.seed(opts.seed)

    rsa = read_pkcs1_prikey(opts)
    if opts.verbose > 1:
        infov(opts, 'RSA Parameters')
        dump_namedtuple(rsa)
    decrypt(opts, rsa)
    infov(opts, 'done')


if __name__ == '__main__':
    main()
